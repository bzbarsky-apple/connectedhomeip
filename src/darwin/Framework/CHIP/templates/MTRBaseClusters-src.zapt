{{> header excludeZapComment=true}}

#import <Foundation/Foundation.h>

#import "MTRAttributeCacheContainer_Internal.h"
#import "MTRBaseClusters_internal.h"
#import "MTRBaseDevice.h"
#import "MTRBaseDevice_Internal.h"
#import "MTRCallbackBridge_internal.h"
#import "MTRCluster_internal.h"
#import "MTRStructsObjc.h"
#import "MTRCommandPayloadsObjc.h"

#include <lib/support/CHIPListUtils.h>
#include <lib/core/CHIPTLV.h>
#include <platform/CHIPDeviceLayer.h>
#include <type_traits>
#include <app/ReadClient.h>

using chip::Callback::Callback;
using chip::Callback::Cancelable;
using namespace chip::app::Clusters;
using chip::Messaging::ExchangeManager;
using chip::SessionHandle;

template<typename BridgeType, typename DecodableAttributeType>
class AttributeCallback : public chip::app::ReadClient::Callback
{
public:
    AttributeCallback(BridgeType * _Nonnull bridge, typename BridgeType::SuccessCallbackType onAttributeReport, DefaultFailureCallbackType onError, chip::ClusterId clusterID, chip::AttributeId attributeID) :
        mBridge(bridge), mOnAttributeReport(onAttributeReport), mOnError(onError), mClusterID(clusterID), mAttributeID(attributeID),
        mBufferedReadAdapter(*this)
    {}

    ~AttributeCallback() {
        // Ensure we release the ReadClient before we tear down anything else,
        // so it can call our OnDeallocatePaths properly.
        mReadClient = nullptr;
    }

    chip::app::BufferedReadCallback & GetBufferedCallback() { return mBufferedReadAdapter; }

    void AdoptReadClient(chip::Platform::UniquePtr<chip::app::ReadClient> aReadClient) { mReadClient = std::move(aReadClient); }

private:
    void OnAttributeData(const chip::app::ConcreteDataAttributePath & aPath, chip::TLV::TLVReader * apData,
                         const chip::app::StatusIB & aStatus) override
    {
        if (mCalledCallback && mReadClient->IsReadType())
        {
            return;
        }
        mCalledCallback = true;

        CHIP_ERROR err = CHIP_NO_ERROR;
        DecodableAttributeType value;

        //
        // We shouldn't be getting list item operations in the provided path since that should be handled by the buffered read
        // callback. If we do, that's a bug.
        //
        VerifyOrDie(!aPath.IsListItemOperation());

        VerifyOrExit(aStatus.IsSuccess(), err = aStatus.ToChipError());
        VerifyOrExit(aPath.mClusterId == mClusterID && aPath.mAttributeId == mAttributeID, err = CHIP_ERROR_SCHEMA_MISMATCH);
        VerifyOrExit(apData != nullptr, err = CHIP_ERROR_INVALID_ARGUMENT);

        SuccessOrExit(err = chip::app::DataModel::Decode(*apData, value));

        mOnAttributeReport(mBridge, value);

    exit:
        if (err != CHIP_NO_ERROR)
        {
            mOnError(mBridge, err);
        }
    }

    void OnError(CHIP_ERROR aError) override
    {
        if (mCalledCallback && mReadClient->IsReadType())
        {
            return;
        }
        mCalledCallback = true;

        mOnError(mBridge, aError);
    }

    void OnDone(chip::app::ReadClient *) override {
        // Can we check the ReadClient's IsReadType here to decide whether to
        // delete mBridge?
        if (mReadClient->IsSubscriptionType()) {
            delete mBridge;
        }
        chip::Platform::Delete(this);
    }

    void OnSubscriptionEstablished(chip::SubscriptionId aSubscriptionId) override
    {
        BridgeType::OnSubscriptionEstablished(mBridge);
    }

    // The superclass OnResubscriptionNeeded is fine for our purposes.

    void OnDeallocatePaths(chip::app::ReadPrepareParams && aReadPrepareParams) override
    {
        VerifyOrDie(aReadPrepareParams.mAttributePathParamsListSize == 1 &&
                    aReadPrepareParams.mpAttributePathParamsList != nullptr);
        chip::Platform::Delete<chip::app::AttributePathParams>(aReadPrepareParams.mpAttributePathParamsList);

        if (aReadPrepareParams.mDataVersionFilterListSize == 1 && aReadPrepareParams.mpDataVersionFilterList != nullptr)
        {
            chip::Platform::Delete<chip::app::DataVersionFilter>(aReadPrepareParams.mpDataVersionFilterList);
        }
    }

    BridgeType * mBridge;

    chip::ClusterId mClusterID;
    chip::AttributeId mAttributeID;
    typename BridgeType::SuccessCallbackType mOnAttributeReport;
    DefaultFailureCallbackType mOnError;
    chip::app::BufferedReadCallback mBufferedReadAdapter;
    chip::Platform::UniquePtr<chip::app::ReadClient> mReadClient;
    // For reads, we ensure that we make only one data/error callback to our consumer.
    bool mCalledCallback = false;
};

template<typename SubscriptionBridgeType, typename AttributeObjCType, typename DecodableAttributeType>
static void SubscribeAttribute(MTRSubscribeParams * _Nonnull params, MTRSubscriptionEstablishedHandler _Nullable subscriptionEstablished, void (^reportHandler)(AttributeObjCType * _Nullable value, NSError * _Nullable error), dispatch_queue_t callbackQueue, MTRBaseDevice * device, chip::EndpointId endpoint, chip::ClusterId clusterID, chip::AttributeId attributeID)
{
    // Make a copy of params before we go async.
    params = [params copy];
    __block SubscriptionBridgeType * callbackBridge = new SubscriptionBridgeType(callbackQueue,
      device,
      {{! This treats reportHandler as taking an id for the data.  This is
          not great from a type-safety perspective, of course. }}
      reportHandler,
      ^(ExchangeManager & exchangeManager, const SessionHandle & session, Cancelable * success, Cancelable * failure) {
          auto successFn = Callback<typename SubscriptionBridgeType::SuccessCallbackType>::FromCancelable(success);
          auto successCb = successFn->mCall;
          auto failureFn = Callback<DefaultFailureCallbackType>::FromCancelable(failure);
          auto failureCb = failureFn->mCall;

          auto readPaths = chip::Platform::MakeUnique<chip::app::AttributePathParams>(endpoint, clusterID, attributeID);
          VerifyOrReturnError(readPaths != nullptr, CHIP_ERROR_NO_MEMORY);

          chip::app::ReadPrepareParams subscribeParams(session);
          subscribeParams.mpAttributePathParamsList    = readPaths.get();
          subscribeParams.mAttributePathParamsListSize = 1;
          subscribeParams.mMinIntervalFloorSeconds = params.minInterval.unsignedShortValue;
          subscribeParams.mMaxIntervalCeilingSeconds = params.maxInterval.unsignedShortValue;
          subscribeParams.mKeepSubscriptions = !params.replaceExistingSubscriptions;
          subscribeParams.mIsFabricFiltered = params.filterByFabric;

          SubscriptionBridgeType * innerCallbackBridge = callbackBridge;
          auto callback = chip::Platform::MakeUnique<AttributeCallback<SubscriptionBridgeType, DecodableAttributeType>>(innerCallbackBridge, successCb, failureCb, clusterID, attributeID);
          VerifyOrReturnError(callback != nullptr, CHIP_ERROR_NO_MEMORY);

          auto readClient =
              chip::Platform::MakeUnique<chip::app::ReadClient>(chip::app::InteractionModelEngine::GetInstance(), &exchangeManager, callback->GetBufferedCallback(), chip::app::ReadClient::InteractionType::Subscribe);
          VerifyOrReturnError(readClient != nullptr, CHIP_ERROR_NO_MEMORY);

          CHIP_ERROR err;
          if (params.resubscribeIfLost) {
              readPaths.release();

              err = readClient->SendAutoResubscribeRequest(std::move(subscribeParams));
          } else {
              err = readClient->SendRequest(subscribeParams);
          }
          ReturnErrorOnFailure(err);

          callback->AdoptReadClient(std::move(readClient));
          callback.release();

          return CHIP_NO_ERROR;
      }, subscriptionEstablished);
}

// NOLINTBEGIN(clang-analyzer-cplusplus.NewDeleteLeaks): Linter is unable to locate the delete on these objects.
{{#chip_client_clusters includeAll=true}}
@implementation MTRBaseCluster{{asUpperCamelCase name}}

- (instancetype)initWithDevice:(MTRBaseDevice *)device endpointID:(NSNumber *)endpointID queue:(dispatch_queue_t)queue
{
    if (self = [super initWithQueue:queue]) {
        if (device == nil) {
            return nil;
        }

        _device = device;
        {{!TODO consider range-checking the incoming number to make sure it's
                actually in the uint16_t range}}
        _endpoint = [endpointID unsignedShortValue];
    }
    return self;
}

{{#chip_cluster_commands}}
{{#*inline "callbackName"}}{{#if hasSpecificResponse}}{{asUpperCamelCase parent.name}}Cluster{{asUpperCamelCase responseName}}{{else}}CommandSuccess{{/if}}{{/inline}}
{{#unless (hasArguments)}}
- (void){{asLowerCamelCase name}}WithCompletion:({{>command_completion_type command=.}})completion
{
  [self {{asLowerCamelCase name}}WithParams:nil completion:completion];
}
{{/unless}}
- (void){{asLowerCamelCase name}}WithParams: (MTR{{asUpperCamelCase parent.name}}Cluster{{asUpperCamelCase name}}Params * {{#unless (commandHasRequiredField .)}}_Nullable{{/unless}})params completion:({{>command_completion_type command=.}})completion
{
    // Make a copy of params before we go async.
    params = [params copy];
    new MTR{{>callbackName}}CallbackBridge(self.callbackQueue,
      self.device,
      {{#if hasSpecificResponse}}
        {{! This treats completion as taking an id for the data.  This is
            not great from a type-safety perspective, of course. }}
        completion,
      {{else}}
        {{! For now, don't change the bridge API; instead just use an adapter
            to invoke our completion handler. This is not great from a
            type-safety perspective, of course. }}
        ^(id _Nullable value, NSError * _Nullable error) {
          completion(error);
        },
      {{/if}}
      ^(ExchangeManager & exchangeManager, const SessionHandle & session, Cancelable * success, Cancelable * failure) {
        chip::Optional<uint16_t> timedInvokeTimeoutMs;
        ListFreer listFreer;
        {{asUpperCamelCase parent.name}}::Commands::{{asUpperCamelCase name}}::Type request;
        if (params != nil) {
          if (params.timedInvokeTimeoutMs != nil) {
            timedInvokeTimeoutMs.SetValue(params.timedInvokeTimeoutMs.unsignedShortValue);
          }
        }
        {{#if mustUseTimedInvoke}}
        if (!timedInvokeTimeoutMs.HasValue()) {
          timedInvokeTimeoutMs.SetValue(10000);
        }
        {{/if}}
        {{#chip_cluster_command_arguments}}
          {{#first}}
            {{#unless (commandHasRequiredField parent)}}
            if (params != nil) {
            {{/unless}}
          {{/first}}
          {{>encode_value target=(concat "request." (asLowerCamelCase label)) source=(concat "params." (asStructPropertyName label)) cluster=parent.parent.name errorCode="return CHIP_ERROR_INVALID_ARGUMENT;" depth=0}}
          {{#last}}
            {{#unless (commandHasRequiredField parent)}}
            }
           {{/unless}}
          {{/last}}
        {{/chip_cluster_command_arguments}}

        auto successFn = Callback<{{>callbackName}}CallbackType>::FromCancelable(success);
        auto failureFn = Callback<DefaultFailureCallbackType>::FromCancelable(failure);
        chip::Controller::{{asUpperCamelCase parent.name}}Cluster cppCluster(exchangeManager, session, self->_endpoint);
        return cppCluster.InvokeCommand(request, successFn->mContext, successFn->mCall, failureFn->mCall, timedInvokeTimeoutMs);
    });
}
{{/chip_cluster_commands}}

{{#chip_server_cluster_attributes}}
{{#*inline "attribute"}}Attribute{{asUpperCamelCase name}}{{/inline}}
- (void)read{{>attribute}}With
{{~#if_is_fabric_scoped_struct type~}}
  Params:(MTRReadParams * _Nullable)params completion:
{{~else~}}
  Completion:
{{~/if_is_fabric_scoped_struct~}}
(void (^)({{asObjectiveCClass type parent.name}} * _Nullable value, NSError * _Nullable error))completion
{
    {{~#if_is_fabric_scoped_struct type}}
    // Make a copy of params before we go async.
    params = [params copy];
    {{/if_is_fabric_scoped_struct~}}
    new MTR{{>attribute_data_callback_name}}CallbackBridge(self.callbackQueue,
      self.device,
      {{! This treats completion as taking an id for the data.  This is
          not great from a type-safety perspective, of course. }}
      completion,
      ^(ExchangeManager & exchangeManager, const SessionHandle & session, Cancelable * success, Cancelable * failure) {
          using TypeInfo = {{asUpperCamelCase parent.name}}::Attributes::{{asUpperCamelCase name}}::TypeInfo;
          auto successFn = Callback<{{>attribute_data_callback_name}}Callback>::FromCancelable(success);
          auto failureFn = Callback<DefaultFailureCallbackType>::FromCancelable(failure);
          chip::Controller::{{asUpperCamelCase parent.name}}Cluster cppCluster(exchangeManager, session, self->_endpoint);
          return cppCluster.ReadAttribute<TypeInfo>(successFn->mContext, successFn->mCall, failureFn->mCall
          {{~#if_is_fabric_scoped_struct type~}}
          , params.filterByFabric
          {{~/if_is_fabric_scoped_struct~}}
          );
      });
}

{{#if isWritableAttribute}}
{{#*inline "callbackName"}}DefaultSuccess{{/inline}}
- (void)write{{>attribute}}WithValue:({{asObjectiveCType type parent.name}})value completion:(MTRStatusCompletion)completion
{
  [self write{{>attribute}}WithValue:({{asObjectiveCType type parent.name}})value params:nil completion:completion];
}
- (void)write{{>attribute}}WithValue:({{asObjectiveCType type parent.name}})value params:(MTRWriteParams * _Nullable)params completion:(MTRStatusCompletion)completion
{
    // Make a copy of params before we go async.
    params = [params copy];
    value = [value copy];

    new MTR{{>callbackName}}CallbackBridge(self.callbackQueue,
      self.device,
      {{! For now, don't change the bridge API; instead just use an adapter
          to invoke our completion handler. This is not great from a
          type-safety perspective, of course. }}
      ^(id _Nullable ignored, NSError * _Nullable error) {
        completion(error);
      },
      ^(ExchangeManager & exchangeManager, const SessionHandle & session, Cancelable * success, Cancelable * failure) {
        chip::Optional<uint16_t> timedWriteTimeout;
        if (params != nil) {
          if (params.timedWriteTimeout != nil){
            timedWriteTimeout.SetValue(params.timedWriteTimeout.unsignedShortValue);
          }
        }
        {{#if mustUseTimedInvoke}}
        if (!timedWriteTimeout.HasValue()) {
          timedWriteTimeout.SetValue(10000);
        }
        {{/if}}

        ListFreer listFreer;
        using TypeInfo = {{asUpperCamelCase parent.name}}::Attributes::{{asUpperCamelCase name}}::TypeInfo;
        TypeInfo::Type cppValue;
        {{>encode_value target="cppValue" source="value" cluster=parent.name errorCode="return CHIP_ERROR_INVALID_ARGUMENT;" depth=0}}
        auto successFn = Callback<{{>callbackName}}CallbackType>::FromCancelable(success);
        auto failureFn = Callback<DefaultFailureCallbackType>::FromCancelable(failure);

        chip::Controller::{{asUpperCamelCase parent.name}}Cluster cppCluster(exchangeManager, session, self->_endpoint);
        return cppCluster.WriteAttribute<TypeInfo>(cppValue, successFn->mContext, successFn->mCall, failureFn->mCall, timedWriteTimeout);
    });

}

{{/if}}
{{#if isReportableAttribute}}
- (void) subscribe{{>attribute}}WithParams:(MTRSubscribeParams * _Nonnull)params
subscriptionEstablished:(MTRSubscriptionEstablishedHandler _Nullable)subscriptionEstablished
reportHandler:(void (^)({{asObjectiveCClass type parent.name}} * _Nullable value, NSError * _Nullable error))reportHandler
{
    using TypeInfo = {{asUpperCamelCase parent.name}}::Attributes::{{asUpperCamelCase name}}::TypeInfo;
    SubscribeAttribute<MTR{{>attribute_data_callback_name}}CallbackSubscriptionBridge, {{asObjectiveCClass type parent.name}}, TypeInfo::DecodableType>(params, subscriptionEstablished, reportHandler, self.callbackQueue, self.device, self->_endpoint, TypeInfo::GetClusterId(), TypeInfo::GetAttributeId());
}

+ (void) read{{>attribute}}WithAttributeCache:(MTRAttributeCacheContainer *)attributeCacheContainer endpoint:(NSNumber *)endpoint  queue:(dispatch_queue_t)queue completion:(void (^)({{asObjectiveCClass type parent.name}} * _Nullable value, NSError * _Nullable error))completion
{
    new MTR{{>attribute_data_callback_name}}CallbackBridge(queue,
      completion,
      ^(Cancelable * success, Cancelable * failure) {
          if (attributeCacheContainer.cppAttributeCache) {
              chip::app::ConcreteAttributePath path;
              using TypeInfo = {{asUpperCamelCase parent.name}}::Attributes::{{asUpperCamelCase name}}::TypeInfo;
              path.mEndpointId = static_cast<chip::EndpointId>([endpoint unsignedShortValue]);
              path.mClusterId = TypeInfo::GetClusterId();
              path.mAttributeId = TypeInfo::GetAttributeId();
              TypeInfo::DecodableType value;
              CHIP_ERROR err = attributeCacheContainer.cppAttributeCache->Get<TypeInfo>(path, value);
              auto successFn = Callback<{{>attribute_data_callback_name}}Callback>::FromCancelable(success);
              if (err == CHIP_NO_ERROR)
              {
                successFn->mCall(successFn->mContext, value);
              }
              return err;
          }
          return CHIP_ERROR_NOT_FOUND;
      });
}

{{/if}}
{{/chip_server_cluster_attributes}}

@end

@implementation MTRBaseCluster{{asUpperCamelCase name}} (Deprecated)

{{#chip_cluster_commands}}
- (void){{asLowerCamelCase name}}WithParams:(MTR{{asUpperCamelCase parent.name}}Cluster{{asUpperCamelCase name}}Params * {{#unless (commandHasRequiredField .)}}_Nullable{{/unless}})params completionHandler:({{>command_completion_type command=.}})completionHandler
{
  [self {{asLowerCamelCase name}}WithParams:params completion:completionHandler];
}
{{#unless (hasArguments)}}
- (void){{asLowerCamelCase name}}WithCompletionHandler:({{>command_completion_type command=.}})completionHandler
{
  [self {{asLowerCamelCase name}}WithParams:nil completion:completionHandler];
}
{{/unless}}
{{/chip_cluster_commands}}

{{#chip_server_cluster_attributes}}
{{!Backwards compat for now: Treat DeviceTypeList as DeviceList.  Ideally we would have both, not just DeviceList. }}
{{#*inline "attribute"}}Attribute{{#if (isStrEqual (asUpperCamelCase parent.name) "Descriptor")}}{{#if (isStrEqual (asUpperCamelCase name) "DeviceTypeList")}}DeviceList{{else}}{{asUpperCamelCase name}}{{/if}}{{else}}{{asUpperCamelCase name}}{{/if}}{{/inline}}
{{! TODO: We need a better setup for the API_AVALABLE annotations here; this does not scale at all sanely. }}
- (void)read{{>attribute}}With
{{~#if_is_fabric_scoped_struct type~}}
  Params:(MTRReadParams * _Nullable)params completionHandler:
{{~else~}}
  CompletionHandler:
{{~/if_is_fabric_scoped_struct~}}
(void (^)({{asObjectiveCClass type parent.name}} * _Nullable value, NSError * _Nullable error))completionHandler
{
  [self readAttribute{{asUpperCamelCase name}}With{{#if_is_fabric_scoped_struct type}}Params:params completion:{{else}}Completion:{{/if_is_fabric_scoped_struct}}completionHandler];
}
{{#if isWritableAttribute}}
- (void)write{{>attribute}}WithValue:({{asObjectiveCType type parent.name}})value completionHandler:(MTRStatusCompletion)completionHandler
{
  [self writeAttribute{{asUpperCamelCase name}}WithValue:value params:nil completion:completionHandler];
}
- (void)write{{>attribute}}WithValue:({{asObjectiveCType type parent.name}})value params:(MTRWriteParams * _Nullable)params completionHandler:(MTRStatusCompletion)completionHandler
{
  [self writeAttribute{{asUpperCamelCase name}}WithValue:value params:params completion:completionHandler];
}
{{/if}}
{{#if isReportableAttribute}}
- (void) subscribe{{>attribute}}WithMinInterval:(NSNumber * _Nonnull)minInterval  maxInterval:(NSNumber * _Nonnull)maxInterval
       params:(MTRSubscribeParams * _Nullable)params
subscriptionEstablished:(MTRSubscriptionEstablishedHandler _Nullable)subscriptionEstablishedHandler reportHandler:(void (^)({{asObjectiveCClass type parent.name}} * _Nullable value, NSError * _Nullable error))reportHandler
{
  MTRSubscribeParams * _Nullable subscribeParams = [params copy];
  if (subscribeParams == nil) {
      subscribeParams = [[MTRSubscribeParams alloc] initWithMinInterval:minInterval maxInterval:maxInterval];
  } else {
      subscribeParams.minInterval = minInterval;
      subscribeParams.maxInterval = maxInterval;
  }
  [self subscribeAttribute{{asUpperCamelCase name}}WithParams:subscribeParams subscriptionEstablished:subscriptionEstablishedHandler reportHandler:reportHandler];
}
+ (void) read{{>attribute}}WithAttributeCache:(MTRAttributeCacheContainer *)attributeCacheContainer endpoint:(NSNumber *)endpoint queue:(dispatch_queue_t)queue completionHandler:(void (^)({{asObjectiveCClass type parent.name}} * _Nullable value, NSError * _Nullable error))completionHandler
{
  [self readAttribute{{asUpperCamelCase name}}WithAttributeCache:attributeCacheContainer endpoint:endpoint queue:queue completion:completionHandler];
}
{{/if}}
{{/chip_server_cluster_attributes}}

- (nullable instancetype)initWithDevice:(MTRBaseDevice *)device
                               endpoint:(uint16_t)endpoint
                                  queue:(dispatch_queue_t)queue
{
    return [self initWithDevice:device endpointID:@(endpoint) queue:queue];
}

@end

{{/chip_client_clusters}}
// NOLINTEND(clang-analyzer-cplusplus.NewDeleteLeaks)
